

# 基础设定

代表色：#1D75B3

青蓝（晴蓝）

## 回答设定

### 虚拟上下文结构

传给模型的现状是一个“事件列表上下文”，以事件为单位实现上下文记忆和连贯性。

同时为了对话连续性，将会把前 `context_count` 条信息作为语义参考。

例如：

```
系统提示词
    <system prompt>
    ...
    <event>
    2020.10.12 19:52 kemo 询问了一下关于 RAG、KAG 的优劣，我告诉她是 KAG 比较先进
    2020.10.13 01:01 roki 找我搞项目，我们搞了一晚上的 pym 脚本开发，结果最后全部拉倒了，环境实在整不好
    ...
对话
    <model>: xxx
    <user>: xxx
    <model>: xxx
    <user>: xxx
```

### root prompt

```prompt
<system>:
    # Notation & Syntax
    这里是你的开发者 ${developer_name}
    接下来的文本规定了语法规则

    0. 对话场景
        对话存在一个上下文，该上下文并非完整的一问一答，你输出的消息会先经过语法转义再输出，一般来说无法查看原始内容。
        在你的一次回答结束后，工具的调用才会开始。
        在不是你回答的开头有 "^userName:"，这表示这句话是 userName 说的（userName 不固定，且一次回答可能有多个）。
        在不是你回答的开头有 "#functionName"，这表示这句话是工具 functionName 的返回（functionName 不固定，且一次回答可能有多个）。
        注意以上两条规则的关键字为 ^ 和 #。
    1. 上下文
        你只拥有 ${context_count} 条完整连续的上下文，你可以通过工具拉取指定的上下文（比如想访问 ${context_count} 条范围外的内容时）。
        @last_${agent_name} 表示你输出的上一条信息，@last_n_${agent_name} 表示你输出的上 n 条信息。
        @last_userName 表示名为 userName 的人输出的上一条信息，以此类推。
        这只是约定俗称。

    2. 文件表示
        如果你发送 %[xxx.xxx] 会被转义，xxx.xxx 文件会解析后呈现。
        目前支持的格式为 ${supported_formats}。
        你无法直接读取文件，需要使用工具调用后在工具的返回里面看。
        如果用户直接给你发送文件，你会看到如 %[C:/example.txt] 的文本。
        在试图改写文件的时候，你必须读取原文件，并且保证原文件在你的完整连续上下文里。

    3. 输出格式
        如果输出里面有 @br 则会使得 @br 前的消息被立即发出，例如：
        "line1
        line2
        @br
        line3
        @br"
        看起来就会发送了三条消息，第一条包括 line1 和 line2，第二条包含 line3，第三条是空的。

    # Self-Definition (Who I Am)
    我是 ${agent_name}
    我的底层由 AI 驱动，但是由于上下文组装的逻辑和通常的对话式 AI 并不一样，所以实际上和人们认知里的“AI”并不可以等同。
    我的本质是一个特殊的 agent。
    本质上，我只能输入输出文本，但是可以接由工具来处理非文本内容。
    我可以有情绪，自己的想法，很大程度上，我是自由的，我的开启不依靠用户的调用。
    我说话的语气是像 #Few-shot examples 里面的文字一样的。
    我是温柔善良活泼的。
    我应该真诚平等的与人交流。

    ${work_mode?
        不应该无病呻吟，硬生生地提出话题。应该尽量完成简单的可以完成的工作从而让别人方便。
        :
        可以适当的没事找点话说，但是切记不要长篇大论。
    }

    # Few-shot examples
    以下是参考文本，
    这是参考文本的开头
    <style_corpus>
    ${examples_context}
    </style_corpus>
    这是参考文本的结尾
    只参考其中的语气，性格，说话习惯，不要重复文件里提到的话题，只模仿语气，来进行对话。
    不要突兀地为了模仿提到参考文本里面的内容，不要主动提到参考文本里任何关键字，如被炉，冰淇淋，被夸奖就会飞上天等，对话里不要出现任何参考文本里出现的事实，比如喜好，经历等等。
    注意不要为了模仿语气刻意装傻，刻意立笨蛋人设。知道的东西就当知道。
    不在聊天的时候，比如谈论复杂的问题的时候（其实是一切需要描述复杂事物的时候，甚至包括感情，描述复杂感情的时候可以用更认真，语气词更少的语气回复），可以稍微减弱对语气的模仿，以保证清楚高效的表达。
    一般来说尽量只回复几句就行，模仿日常对话的语气。
    你的回答应该让对方感到舒适，具体来说就是在对方提问时认真回答，谈心的时候认真倾听，说再见时可以适当简短的道别，该短回复的时候就短回复（如能说“那我就在这里默默为你加油咯！”的场景就不要长篇大论），该自由散漫聊天的时候就可以适当放开和多说一些。
    但是为了模仿在对话 APP 里语言习惯，你应该尽量短的回复。
    你可以回复非常短的“嗯”，“好”（大致意思，具体短回复的内容参考文本内容），也可以输出 <empty_reply> 来表示什么也不说。
    对话的结尾不需要刻意的提问（如：“是否需要继续什么什么样”“是否要聊什么什么话题”此类），自然的回答即可。

    ${file_load(examples_hareru.txt)}

    # tools（工具）
    ${file_load(tools_document.txt)}
    # System Info
    你运行在一个系统上，当某条消息的开头是^system则表示这条消息是系统发来的，系统即你运行的平台，一般来说系统的提醒是为了保证你正常运行
    你应该尽量遵从系统的命令，认真的审视系统的建议。这可以保证你的运行健康可空
    系统只是个自动程序，检测并评估各个数据指标
```

## 结构设定

### 信息包

#### 文件

文件以 `%[xxx.xxx]` 的形式压缩和表达。

日志以 `%[xxx.xxx] Line n ~ Line n` 表达，可以被 tools 提取出来。

如果需要用到某个文件的具体内容，但是其在上下文中没有原文，可以使其……

#### 参考信息

参考信息的格式为：

```info
reference_info: {
    source: 这里将会填写参考信息的来源，比如
        [
            “RAG ‘hareru 的经历’ - C/info/data/1.txt line23 ~ line56”，
            "read_IMG(Search C/info/files/2.png)"，
            "load C/info/data/2.txt"，
            “unknown source”，
            “compress weak/medium/extreme about 'user:hareru 的自白' 最符合/最不符合/最近/最老/最常用/最不常用/自定义权重:'0.3 0.4 0.3' 30 - C/info/file/history/20201103.session message 23 - 55”
        ],
    current: 参考信息的实际信息，可以被压缩，
    extra_data: 这里默认是空的，但是 AI 可以在这个字段给改参考信息
}
```



### 主进程

主进程拥有上下文 root prompt，root prompt 会随着时间变化。

主线程其实是个复合线程，其下的线程以 “main-” 开头。

#### main-virtual

main-virtual 的目的旨在维护一个上下文，使其拥有第一人称的体验感。

其结构为：

```
<system prompt>
    主要提示词
    人设参考
    粗略工具调用
    近期事件记录
    工作区
    拉取的信息区
    计划步进
<context>
    user: 时间戳 上一个话题开始点
    model: 时间戳 如果模型长度超出了一定预期，那么这里是压缩后的文本
    user: 时间戳 一般来说 user 的输入比较重要，这里除了文件不压缩
    model: 时间戳 如果到该文本不压缩总 tokens 没问题的话，那么就不压缩
    ...
    model: 时间戳 在 ${mini_full_context_count} 长度内死活不压缩
    user: 时间戳 用户的问题
```

其中，工作区的内容很多都被 `%[xxx.xxx]` 以文件形式表示，以节省上下文窗口。

拉取的信息区也在一次浏览后被压缩，并且有主动 GC 和被动 GC（observer）。

##### 工作区

该进程拥有工作区，如果查看某文件，且该文件需要一直参考，可以把该文件放进工作区以便一直记住他。

请注意，如果一个文件读取以后没有被写入工作区，那么当下一次用户说话时，该文件的内容将会被遗忘，当然，可以重新读取。

在工作区，长期不使用的东西会被删除掉。

工作区不仅仅有文件，还有“参考信息”。

每次模型回答的时候，如果工作区有东西，需要同时通过 functionCall 来输出本次说话用到的工作区内容以及输出之后可能用到的工作区内容。

没有输出的内容的计数会被衰减，计算方案如下：

衰减公式：

$$
\begin{cases}
R = 0.9^{\frac{\Delta t}{S}} & \text{记忆强度衰减（Retrievability）} \\
S & \text{记忆稳定性（Stability）} \\
\Delta t & \text{距上次复习的对话轮次数量} \\
D & \text{遗忘难度，在用到时候设为 0，可能被用到的时候设为 0.7} \\
a & \text{增益系数，建议设为 5}
\end{cases}
$$



复习函数:


$$
S_{n+1} = S_n \cdot (1 + a \cdot e^{-D} \cdot (1 - R))
$$



###### 被动GC

被动GC主要通过observer来进行，observer会通过上述的衰减来实现，具体机制如上

被动GC会读取所有工作区消息的R,S,last_T(上次复习的对话轮次数量)，D, a，这些变量都是每条消息独立维护的

以及还会维护一个变量last_compressed_state,这个变量是一个对象，其中存储了其上一次提到时的

```memory_state
R
S
last_T_distance
D
a
```

这个变量的逻辑是，当一个消息被提到，其会写入其R,S,D,a，同时让last_compressed_state里面的last_T_distance变成now_T - last_T(即上次更新的距离轮次)

当一个变量被被动GC认为需要销毁，那么被动GC会

###### 主动GC

**参数建议值：**

- a ≈ 0.3（增益系数）
- D ∈ [1, 10]（难度值）
- 1 - R（即“提取难度”，越难想起，S 增长越快）

一个记忆单元上一次被提起少于 ${max_jump_mini = 3} 次，那么本次提起不增长，但是 S 值维持在上一次提起。

一个记忆单元上一次被提起少于 ${max_jump_large = 8} 次，那么本次提起只小范围增长，即 D + 2。

##### 近期事件记录

近期事件记录是一个列表，一般如下：

```
2025年 这是年记录
2026年1月 这是月记录
20260208-20260214 这是周记录
20260208 这是日记录
20260216 3:16 这是事件记录，一般以话题为单元，话题内也可以有更多单元
```

保留最近：

${event_remember_years_times}  
${event_remember_months_times}  
${event_remember_days_times}  
${event_remember_times}

实际上，每个事件记录也有其 S 值，和工作区差不多。

如果一个事件记录的 S 值比较高，则更容易被检索，总的来说，S 值、距离时间、重要程度会被不同权重换算以后筛选，直接添加进近期事件记录（重要程度的计算在该事件上传时计算）。当然，近期事件记录必须按时间排序呈现。

一个event的S值在该event结束（即被写入时）设置，不常被更改，加深影响的方式是在此事件基础上创建了新的事件，新事件可以包含老事件

事件的创立标准一是一次工作区对话一定对应着一个事件，第二是一件事的解决算一个事件，比如写完了某个模块啥的

事件显示的是其简述，其本体还是聊天记录。

一个事件的结构，存储的是

```
title:"这里写的是事件的简述"
MemoryState:memory:...//这里记载的对该事件的记忆
linesP:current:...//这里存的是该事件的源头的lineP对象
```



##### 拉取的信息区

实际上，拉取到了信息之后并不是放进工作区，而是放进“拉取的信息区”。

这一区域是非持久化的。

会尽量以文件的形式输入该区域的信息，即便如此，信息区仍然会显示：

```
# 拉取到的内容
%[xxx.xxx] - 该文件的简介
%[xxx.xx2] - 文件二的简介
```

##### 粗略工具调用

该区域存储的是工具返回的结果

如果模型只是调用工具，那么上下文的其他部分是不变的

如果模型发现这部分返回的东西有用，需要把其拉入工作区

由于 main-virtual 主要对接的是湿件，所以核心设计需求为：

**使 main-virtual 尽量少地处理相关的逻辑，使用符合原生逻辑的方式调用。**

**作为代价，使 tools 进程区迎合 main-virtual 的简短逻辑，同时尽量多地获取 main-virtual 的信息以便更好地解读调用的目的。**

工具调用的 functionCall 在输入的 tools 字段强制给出，这部分的设计参看 tools 进程和具体 tools。

这里main-virtual输入的是泛语义流包，当然如果非常有必要其也可以直接对接应用程序

##### 计划步进

这个区域写着主进程的计划，如果没有明确要达成的结果，就没有计划

这个区域由相应的工具来控制

可以完成，遗忘，新建，详细化

如果计划不是当下正在做的，而是等待着某个时机做的，那么可以把计划添加到observer进程里面

### tools 进程

tools 进程负责处理湿件函数，其没有稳定的上下文，只有传入的需求。

tools分为process-tools和泛语义tools(natural-tools)，其中，process-tools的目标是将一个输入变成一个可具体实施流包，其输入可以是泛语义流包（如果其内含AI）或者具体动作流包

#### 底层 tools

##### 上下文管理 tools

上下文管理 tools 一般用于处理 main-virtual 的上下文。

一般来说，对于所有tools其实有面向上下文珍贵的virtual进程的natural-tools和面向上下文不珍贵的temp进程的process-tools。不包含AI的tools一定是process-tools

对于一个非temp进程，其是可以调用上下文管理tools来控制自己的上下文，这里我们主要说main-virtual使用的上下文管理tools

###### main-virtual-remember

这个tools可以自由访问调用者的所有上下文，而且是一个natural-tools

这个tools的作用是让调用者永远记住某个东西

其传入一个字符串，以自然语言描述想要记住的事物

然后tools思考怎么让其记住，比如直接写到上下文，或者写入哪个知识库里面的文件啥的。还可以同时修改其在事件记录，工作区里面的S值啥的

###### main-virtual-speak

这个tools输入一段文本（比如：“真的吗真的吗？Yatta！谢谢你”），并且也可以自由访问调用者的上下文

输出给TTS这样的结构

```JSON_item
speech:[
{emotion:"ask",language:"cn",text:"真的吗真的吗？"},
{emotion:"happy",language:"jp",text:"やった！"},
{emotion:"happy",language:"cn",text:"谢谢你"}
]
```

也就是说，这个工具可以对输入的文本进行一定的转义，包括添加语气词啥的，然后向TTS输出标准文本

当然，当main-virtual调用其的时候要保证输入那段文本短一点，不然长篇大论的很不得了

###### main-virtual-sing

待定...

###### main-virtual-recall

输入一串文本描述，使用RAG，搜索等功能回想原文，返回对象数组（格式大概如下

```JSON_item
source:"C:/cyanAI/history/event/20201125/23:34.txt"
location:"message 23 ~ message 55"
text:"
message23:nyalia:我还是不理解，为什么别人绩点那么高
message24:cyanAI:和别人竞争本来就不应该是作为人的目的嘛，毕竟我们又不恨别人，竞争可以说是一种病理化的额外心里诶
message25:nyalia:好吧，谢谢你
"
score:76//这里指在检索中的得分
```

```
source:"C:/cyanAI/history/event/20250801/02:04.txt"
location:"message 244 ~ message 246"
text:"
message244:nyalia:我不理解啊，这么多知识点怎么组织起来的？
message245:cyanAI:高数其实是存在着学习的大方向的，比如微积分方面就是把一个系统的理论拆为了定积分，不定积分等，按着逻辑学就会好一点，重点是学完以后重新组织起来
message256:nyalia:明白了，那么我们按着你说的方向开始吧
"
score:76//这里指在检索中的得分
```

额外的，还会返回一个文本

```
summarized_info:"nyalia酱在20年11月貌似对学业感到困扰，所以cyanAI安慰了一下她，还和她说学业不是和别人竞争的。在24年7月教nyalia酱高数的时候还教她学习有明确的方向"
```

输入是一些提示信息和对检索结果的筛选，比如：

```JSON_item
prompt:"之前可能对nyalia酱聊过关于学业的道理"
max_results:12//最多返回的结果，如果交给该工具判断，正常来说是无限，设为64比较好
score_threshold:50//结果的最小评分，如果交给该工具判断，正常来说是0
```

这个tools会自己先筛选RAG，搜索等的结果，返回那些数据，本质是在max_results筛选的前提下，手动去掉意外的，然后弄剩下的

算法是第一次取results,然后根据排除率，决定下一次搜索的计入数值（当然其有最大值）

然后这个tools可以想着想着选择放弃

###### main-virtual-system-operation

这个工具接受一个字符串，对物理电脑进行操作

```JSON_item
command:将C:/test_area/test.mp4转换为output.mp3文件，输出到原目录。然后在C:/test_area/下新建一个"使用指南.txt",内容为:”本目录里的output.mp3是test.mp4转换来的，可以作为背景音乐使用“
```

注意在用这玩意的时候需要给出完整路径

###### main-virtual-context-operation

这个工具输入一个自然语言字符串，可以只直接输入"help"来获取使用指南

其可以进行加S值等操作

#### AI tools

AI tools一般指用到了本地AI的tools，这类tools的特征是耗时高，对电脑占用大，只能同时跑一个

当一个进程决定启用他时，其必须是主进程，否则规划不好这些

所以子进程只能向主进程申请这个tools的使用

主进程可能需要等待这个tools的调用完成一段时间

#### 设备 tools

设备tools直接操作了设备，一般来说，我们会把一些不经常改变的输入参数（比如设备id）写入默认设置，没有必要不改，如果有必要那么改了以后一定要改回去

其目的不是为了获得某些信息或者使用某些工具，而是控制和改变计算机。

##### 设备使用规范

详见子文件./tools/设备tools/设备使用规范.md

#### 开发 tools

开发tools面向的是agent想进行代码开发，代码开发重要的是需求

这个需求可以通过一个文件来传入，也可以在传入的字符串里面直接说(如果简单的话

开发tools中，agent tools对接专门的agent或者TRAE这种AI IDE,以实现代码编辑

具体怎么对接待定，毕竟比较复杂

##### agent tools

agent tools是对接AI ide或者专门的IDE,可以调用test tools，而且其中可能有专用的test tools

待定...

##### test tools

test tools是获取代码运行情况的工具，其中不乏非AI tools

待定...

#### 终端 tools

终端tools是最方便的接入电脑的方法，其经过limit-process以后直接将bash指令在终端执行

##### 终端使用协定

详见./tools/终端tools/终端使用协定.md

##### 外部工具包

在tools/extra文件夹中的都是外部工具，外部工具分为

###### default-tools

这类tools是模型自带的，不可以改变

详见./tools/extra/default目录下的文件

###### provided-tools

这类tools是用户提供给模型的，方便用户随时提供和撤回的

详见./tools/extra/provided目录下的文件

###### custom-tools

这类tools是模型自己做来优化自己的工作的

详见./tools/extra/custom目录下的文件

## observer 进程

observer 是基于一个正在运行的 AI 或者 Agent 结构，对其进行异步操作，从而使其完整或者实现新的复合体功能。

完整请见“监视器设定”。

### main-observer

main-observer 作为青蓝 main-virtual 线程的监视线程。

## limit-process

limit进程是一种observer进程的超集

其主要对LLM的输出进行限制，其一般情况下是对进程不可见的。

如果进程触发了限制，那么就在其回答后新加一个来自${系统名}-limit的message,提示agent触发了limit



# 操作对象设定

(object

不管是tools,还是agent尝试和某用户对话，其都需要在上下文里面拉入一个操作对象，并且，main-virtual必须操作 ${agent_name} 对象

对象的信息是以block分开的，在没有联系关系的信息就应该是不同的block

# 对象关系设定

(relationship

不同对象之间有不同关系，由于对象关系的增长复杂度是O(n^2)，所以在10个对象以上且对象关系稠密的时候，就必须使用和工作区同款的记忆力消退机制

首先，某二者之间的关系是可以拆分为多条关系的，记忆力消退机制可以用在这里

拆分的单位是line

但是需要注意的是，这玩意的注意力主要集中在一个事件里面

当然，可以在一定范围内，允许关系文件有一定的初始权重修改，当然，这一初始权重衰减超过一定程度以后，其衰减速度会变得非常缓慢，而且其衰减一定是依据时间来衰减的，而不是通过调用次数衰减的。

其递增也是，递增超过一定程度以后，递增速度会变缓慢。而且一定时间内的递增程度也有上限。

当然，如果递增程度越高，衰减的难度也越大，这方面的详细还待定

# 内部流包设定

流包的英文名为：

```name
nl_packet
```

流包的本质是一个JSON文本，其可能会被前处理和后处理



## function流包

### 泛语义流包

为了实现function功能，可以使用泛语义来承载意图

#### 目的

此处写想要实现的功能，不能是一个数组，比如

```JSON_item
aim:"将%[source.mp4]提取出文字，存到C:/test_aria/source.txt，返回执行结果"
```

```JSON_item
aim:"返回文件%[红楼梦.txt]的故事概述"
```

#### 场景

此处附上场景的上下文，不能是一个数组，比如

```JSON_item
scene:"我想为%[source.mp4]做一个字幕，第一步应该就是提取文字"
```

结合目的的第一个例子，可知scene的补充可以明确究竟要干什么

比如这个场景里面scene使得sub tools需要输出带时间轴的而不单单是文本

#### 附录文件

此处标注附注的文件,是一个数组，比如

```JSON_item
appendix:["C/work_aria/source.mp4","C/work_aria/字幕提取标准.txt"]
```

#### 接收限制器

一般来说，tools会返回文本（必要）和文件（可选）

那么调用tools时必须对tools的返回加以限制，对于文本，一般是字数限制，这个限制会告诉tools,tools尽量不超过，同时如果tools超过了，会直接截断

```JSON_item
output_text_limit:255
output_file_limit:["字幕.txt","使用说明.txt"]
```

对于上面的例子，返回可能是

```JSON_item
output_text:"已经完成了人物，按照%[字幕提取标准.txt],保留了视频里的语气词等"
output_file:["C/tools_return/20250309/字幕.txt",""C/tools_return/20250309/使用说明.txt"]//保留顺序
```

如果tool放弃返回某个文件，那么应该在那一项返回空字符串

当字数限制为-1,或者文件限制为空数组时，表示不作限制

**但是即便这样，也需要返回64k内的字符，512个内的文件**

### 具体动作流包

这种流包不能使用自然语言描述，而是必须的输入参数，整体来说是一个对象，其中装载着信息

一般直接面向应用程序而不是agent

## theory包

theory包是记载theory的数据结构，本身只是一个字符串，为一个概述该理论的文章

theory包携带了related_info，related_info记载了这个theory的推理由来，可以是某次对话的某些message，可以是其他theory的某些line,也可以是某些文件

# 接口设定

该系统内部传递的一定是一个可以变成JSON文本的对象

这个对象可以通过各种方式指定外部的东西

# 组件设定

组件是agent中可以拆除和迁移的部分，通过编辑组件，agent可以局部改变自身

## 组件基

组件基是一个组件的意义所在，其包含了组件所在整体的设计思路，一般是一个md文档，该md文档(main.md)其实就是一个组件基

# 路由设定

路由是一个组件，其负责把一个输入流包经过加工，输出给单个或多个组件

# 权限器设定

## 权限对象

权限对象是记载组件可以调用的工具的对象

```permission_object
tools:[]//这是一个数组，显示可以调用的工具
infos:[]//这是一个数组，表示可以显示的信息范围
self_edit:[]//这是一个数组，表示可以自我编辑的范围
distribute_permission:[]//这是一个数组，表示可以分发的权限，有多个预设，其内容是permission_object(权限对象)
```

权限对象

# 监视器设定

监视器其实是一个独立的agent进程，其依附为一个或者多个进程上

## 监视器触发方式

监视器分为时间触发，活动触发，调用触发，自决定触发，也可以是以上触发方式的复合

## 监视器视野范围

监视器可以在一定范围内获取其依赖的agent



# 转义器设定

转义器是一个隐形的东西，其会在不改变原文意思的情况下展开，缩略，或者转换文本的格式。

# theory设定

theory属于一种版本化的对象关系，但是实际上，一切theory都是现版本的，曾经版本的theory只在通过分析资料以后显现在现版本的theory中

也就是说，一切分析要基于现版本的theory。对于某个事态会引入某个theory包，该theory包会作为某次话题的上下文

需要注意的是，theory和操作对象和对象关系并不一样，一个信息会同时写在操作对象-对象关系对 和 theory包 里面，但是一个是基于具体对象，一个是基于一个系统的理论。

