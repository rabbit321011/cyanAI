虚拟上下文的实现方式为维护

```
<system prompt>
    主要提示词
    人设参考
    粗略工具调用
    近期事件记录
    工作区
    拉取的信息区
    计划步进
<context>
    user: 时间戳 上一个话题开始点
    model: 时间戳 如果模型长度超出了一定预期，那么这里是压缩后的文本
    user: 时间戳 一般来说 user 的输入比较重要，这里除了文件不压缩
    model: 时间戳 如果到该文本不压缩总 tokens 没问题的话，那么就不压缩
    ...
    model: 时间戳 在 ${mini_full_context_count} 长度内死活不压缩
    user: 时间戳 用户的问题
```

其中，粗略工具调用，近期事件记录，工作区，拉取的信息区都是可变的，而且基本在每次chat或者reAct后都会更新

(其实虚拟上下文的设计哲学可以视为只能自动触发的工具，那么一次agentChat就可以视为一个WATTING,其需要写进虚拟上下文的部分的部分可以视为其创建的TASK)

(但是)为了方便维护，我把虚拟上下文还是写死进程序，其逻辑是，是把虚拟上下文发送给LLM前，先获取各个虚拟上下文的部分以组织虚拟上下文

agent运行的周期可以分为：
chat,reThink

chat即一般输出一次对话，reThink包括接受多次toolsCall的调用LLM

在reThink中，大部分上下文是不变的

为了让模型不在过长的reThink中撑爆上下文，reThink如果超过一定轮次则必然会触发强制的chat，这种强制的chat需要让模型自己去再进行一下保留信息的操作

强制chat是依靠在模型自己的reThink中注入看似是用户的系统信息来控制的